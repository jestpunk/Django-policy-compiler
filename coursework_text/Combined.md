# Введение

При проектировании и создании любой системы, подразумевающей наличие нескольких пользователей, крайне важно продумать политики прав доступа и разграничения, накладываемые на участников этой системы. Если необдуманно подойти к этому вопросу, не формализовать систему, по которой одним пользователям разрешены конкретные действия, а другим нет, поведение системы очень скоро окажется непредсказуемым.

Если же мы говорим о наукометрической системе, объединяющей десятки тысяч сотрудников, сотни тысяч докладов и затрагивающей профессиональную жизнь людей, то здесь вопрос чёткого разграничения прав доступа является вопросом жизни и смерти.
Именно такой системой является ИСТИНА (Интеллектуальная Система Тематического Исследования Наукометрических данных), вдохновившись моделью которой я и взялся за текущую работу. 

Внутри системы реализована модель разграничения доступа ChRelBAC, описанная в статье[1] Кривчикова М.А, Васенина В.А., Иткеса А.А. Суть модели заключается в том, что все её объекты — будь то пользователи, факультеты или статьи — соединены цепочками отношений из некоторого объемлющего набора. Тогда для того чтобы понять, имеет ли какой-то объект определенное отношение или право определенного действия (скажем, может ли пользователь редактировать работу или назначить другого пользователя соавтором) достаточно проверить, существует ли цепочка, обеспечивающая это действие, из списка предложенных разработчиками

Такой набор заранее приготовленных цепочек называется политикой доступа, и грамотное, непротиворечащее их составление является ключевой частью работоспособности модели.

Однако помимо математически строго аппарата работы такая система должна быть нагрузоустойчивой. При столь большом количестве объектов, сколько присутствует в ИСТИНЕ, задача оптимизации кода является не менее значимой, чем задача правильной формализации. В этой работе будет произведена пусть упрощенная, но попытка оптимизировать процедуру проверки политики путём создания компилятора политик доступа, работающего внутри Django-проекта системы (именно на этом фреймворке написана ИСТИНА) без необходимости производить промежуточные преобразования политик.

&nbsp;

# Модели доступа. ChRelBAС.

В данной главе мы обзорно опишем некоторые модели доступа, лежащие в них объекты и протоколы, по которым они взаимодействуют. Основное внимание здесь умышленно уделено модели ChRelBAC — ведь именно её мы реализуем в ходе работы.

&nbsp;

### RBAC

Разграничение доступа на основе ролей (RBAC)[3] — модель, внутри которой каждому объекту присваиваются роли. Именно на их основе и выдаются права доступа к тем или иным объектам. Проблема этого подхода проявляется, когда правила углубляются и становятся вложенными (внутри одного правила может быть масса доуточняющих правил). В этом случае в качестве роли придется использовать уже всевозможные комбинации различных параметров. 

Например, если на разграничение прав влияют профессия и страна проживания человека, в рамках модели RBAC нам придется вводить роли "Бухгалтер Россия", "Аналитик Турция" и прочие, что неоправданно раздувает модель, лишает её ясности. С помощью этой модели невозможно работать с правилами, задействующими заранее не известные атрибуты, а также с правилами, которые ограничивают доступ не к действиям, а к данным. Конечно, все вышеописанные проблемы на практике можно обойти, но это будет трудоёмкий процесс, делающий разработку дорогой и громоздкой.

&nbsp;


### ABAC
Разграничение доступа на основе атрибутов (ABAC)[2] — это модель доступа, основанная на анализе правил для атрибутов объектов или субъектов, возможных операций с ними и окружения, соответствующего запросу. Она решает многие проблемы модели RBAC. Основное отличии ABAC от RBAC состоит в том, что каждая ситуация оценивается не с точки зрения ролей пользователя и ресурса, а с точки зрения атрибутов, которые к ним относятся. По сути накладывается фильтр на различные поля моделей данных. 

Помимо присутствующих во множестве моделей *объекта*, *субъекта* и *действия*, в модели ABAC необходимо так же задать *окружение*, контекст операции.  Окружение может включать в себя геолокацию объекта, временной промежуток операции и любую другую полезную метаинформацию. 

Таким образом, эта модель является гораздо более гибким аналогом RBAC. Она решает все проблемы, описанные для RBAC, часть фильтров можно вычислять еще до обращения к ресурсу, оптимизируя запрос.

&nbsp;

### XACML

XACML (extensible access control markup language) является стандартом для модели ABAC. 
С точки зрения этого стандарта любое правило состоит из нескольких величин 

- объект (то, к чему запрашивается доступ)
- эффект
- условие (набор сложных фильтров и выражений)
- обязательства
- рекомендации

Правило может быть как разрешающим, так и запрещающим. Для этого в правило добавляется величина "эффект". Она и хранит булеву величину, отвечающую за вид правила. Обязательства и рекомендации отличаются между собой исключительно с точки зрения необходимости их выполнения. 

Политика, согласно этому стандарту, также состоит из нескольких полей

- цель
- правило
- алгоритм комбинации правил
- обязательства
- рекомендации

Алгоритм комбинации правил отвечает за то, по какому принципу мы проверяем каждое отдельное правило и принимаем решение о применении эффекта. Например, самым популярным алгоритмом является "запрещено, если не разрешено", который проходит по всем разрешающим правилам и разрешает доступ только при выполнении одного из них.

&nbsp;

### ChRelBAC

Наконец, рассмотрим модель доступа на основе цепочных взаимодействий (chain relation based access model, ChRelBAC)[1], ведь именно на её основе и реализован проект. Данная модель состоит из следующих объектов:

- $Objects$ — абстрактное множество объектов системы. Это могут быть пользователи, дипломы, статьи и так далее.
- $Users \subset Objects$ — подмножество объектов, которое мы считаем пользователями, то есть авторами действий
- $Classes$ — множество классов, которые присваиваются объектам
- $Actions$ — множество действий, которые может выполнять пользователь
- $Relations$ — множество отношений между двумя объектами
- $Primitive\;relations \subset Relations$ — базовые отношения, на основе которых строятся все остальные
- $Induced\;relations = Relations / Primitive\;relations$ — порожденные отношения
- $Chains$ — цепочки взаимодействий

В модели ChRelBAC вводится понятие цепочки. По сути это последовательность отношений, по цепочке связывающая объекты системы. Иными словами, если считать объекты вершинами некоторого графа системы, а отношения рёбрами, то цепочка есть путь в графе.

Согласно этой модели, действие разрешено если и только если между двумя объектами проходит цепочка отношений, разрешающая данная действие, и не проходит ни одной цепочки, запрещающей это действие. Поэтому реализация компилятора политик для этой модели сводится к последовательному перебору различных правил с учётом их метки. Ньюансам программной реализации посвящены следующие главы текущей работы.

&nbsp;

# Компилятор разграничения доступа

Существенным недостатком текущей реализации модели ChRelBAC в репозитории портала ИСТИНА является сложность проверки политик прав доступа. Для этого каждая политика переводится в набор строковых SQL-запросов, и для каждой политики этот запрос хранится отдельно в репозитории. Вместо этого предлагается сделать один программный модуль, отвечающий за проверку прав доступа и не хранящий в себе никакой дополнительной информации.

Таким образом перед нами встаёт задача проверки политик с помощью всего одной булевой функции `check_permission`, без преобразований класса `policy` в какие-либо промежуточные форматы. Эта функция должна быть ёмкой, тестируемой и изменяемой. При этом компилятор политик должен каким-то образом поддерживать проверку всевозможных отношений между объектами (прямых и обратных), их фильтрацию и применение логических операций.

Всё это становится возможно благодаря `ORM` (Object Related Model) модели внутри фреймворка Django. Она предоставляет программную прослойку между базой данных проекта и исполняемым кодом. Так, например, имея следующие модели


```Python
class User(models.Model):
	user_name = models.CharField('Имя пользователя', max_length=50)
	departments_employee = models.ManyToManyField('Department', 
						   related_name='employee_of_department', 
						   blank=True)
	departments_representative = models.ManyToManyField('Department',
	                       related_name='representatives_of_department',
						   blank=True)
	is_superuser = models.BooleanField('Является админом?',
						   default=False)
	papers_of_user = models.ManyToManyField('Paper',
						   related_name='users_of_paper',
						   blank=True)


class Paper(models.Model):
	paper_name = models.CharField('Название статьи', max_length=50)
	paper_text = models.TextField('Текст статьи')
  

class Department(models.Model):
	department_name = models.CharField('Название отдела', max_length=50)
```
*листинг 1*


мы способны обращаться к базе данных проекта, чтобы производить операции `select`, `join` и другие над объектами и, например, получать записи обо всех пользователях, которые являются авторами статьи с названием "ChRelBAC". Пример соответствующего кода описан в листинге 2.


```Python
User.objects.filter(papers_of_user__paper_name='ChRelBAC'))
```
*листинг 2*


Для доступа к подобного рода манипуляциям у каждой модели имеется свой собственный менеджер `objects`, у которого и вызываются все манипуляции с базой данных.

Получается, что для проверки наличия прав доступа между объектами `source` и `dest` нам необходимо пройтись по множеству политик доступа и для каждой из них рассмотреть цепочку зависимостей, фильтров и условий, описанных в политике. Если данная цепочка обнаружена (итоговый `join` двух таблиц содержит `source`), то `source` имеет по отношению к `dest` вид доступа, описанный в политике.

Заметим одно важное преимущество такого подхода — он очень легко расширяем на запрещающие политики. Нет никакой сложности внедрить в описание политики её вид (разрешающая или запрещающая) и блокировать доступ при удовлетворении запрещающей цепочке.

Также для удобства дальнейшей разработки будет не лишним интегрировать в проект версионирование, контроль пакетов, систему тестов и форматтер кода для поддержания стандартного стиля написания.

Теперь, когда описано общее представление об этой функции, давайте посмотрим на непосредственно реализацию компилятора и сопровождающих его модулей.

&nbsp;

# Практическая реализация 

### ООП структура

Текущая реализации компилиятора политик основана на трёх структурах. Первая из них — категория правила, находящегося в политике. Очевидно, что для этих целей отлично подойдет ENUM перечисление. Напомним, что в реализуемой модели доступа ChRelBAC существует всего 2 категории: разрешающие и запрещающие правила

```Python
class Rule_category(Enum):
    """
    Категория для правила,согласно модели ChRelBAC
    Может быть разрашающей или запрещающей
    """
    ALLOWED = 1
    PROHIBITED = 2
```
*листинг 3*

Далее используя категорию правил реализуются сами правила, содержащие цепочки последовательно вызываемых атрибутов объектов (те самые цепочки из модели ChRelBAC, реализованные пока что как список строковых названий полей), название политики (в будущем рассматривается поддержка псевдонимов). По сути это не более чем `dataclass`, поэтому его реализацию мы опустим, вы сможете прочитать её в приложении или репозитории проекта.

Однако важно заметить, что в описании цепочки оставлена возможность составлять выражения с условиями на конечное поле, согласно синтаксису Django callout (об этом ниже в подглаве "Функция is_chain_exist"). Для этого последний элемент цепочки должен быть кортежом, у которого первый элемент это строковое описание фильтра в синтаксисе Django callouts (например "gte" для фильтра "больше или равно"), а второй элемент это фильтрующее значение, с которым мы сравниваем поля финального объекта.

Наконец, все правила объединяются в политику. Она хранит в себе двумя независимыми словарями (для быстрого доступа по имени, что будет полезно при расширении функционала). Оба словаря хранят пары "ключ — значение" вида  "название правила — объект правила". Один из словарей отвечает за разрешенные правила, второй за запрещенные. Не смешивая все правила в одну кашу мы, например, можем заранее отдельно проходится по запрещенным правилам и в случае выполнения какого-то из них запрещать доступ без просмотра разрешающих правил.

&nbsp;

### Функция компилятора

Вызываемая извне функция компилятора `compiler_function` имеет сигнатуру, позволяющую вызывать её схожим с устным образом. Для проверки доступа объекта `source` к объекту `dest` с меткой доступа `label` используется вызов `compiler_function(source, label, dest, policy)`. Так, если у нас имеется представитель модели `User`, описанной в прошлой главе, под названием `some_user`, аналогичный представитель модели `Paper` `some_paper` и мы хотим проверить разрешённость доступа с меткой `edit`, вызов будет весьма наглядным:

```Python
some_user = User(...)
some_paper = Paper(...)
compiler_function(some_user, 'edit', some_paper, policy) # True/False
```
*листинг 4*

Заметим, что последний аргумент функции `compiler function` с листинга 4, содержаший в себе политику доступа, должен в дальнейшей работе быть удалён и вызываться как внешний пакет.

Эта функция реализует верхнеуровневый контроль проверки. Например, внутри неё определяются разрешенные и запрещенные правила объекта политики, а так же менеджеры Django ORM, описанные в предыдущей главе:

```Python
source_manager = type(source).objects
dest_manager = type(dest).objects

allowed_rules = policy.get_allowed_rules()
prohibited_rules = policy.get_prohibited_rules()
```
*листинг 5*

Далее для каждого запрещающего правила мы вызываем вспомогательную низкоуровневую процедуру `is_chain_exist`, проверяющую, существует ли описанная в правиле цепочка между `source` и `dest`. Если какая-то из цепочек была найдена, доступ тут же запрещается (функция возвращает `False`), иначе такая же проверка происходит для всех разрешающих правил. Только теперь при нахождении цепочки, соответствующей правилу, мы наоборот разрешаем доступ (функция возвращает `True`). Если ни одной цепочки не было найдено, в соответствии с моделью ChRelBAC доступ запрещен (функция возвращает `False`). Программная реализация показана на листинге 6.

```Python
for r in prohibited_rules:
        if label not in r.get_labels():
            continue

        if is_chain_exist(r, source_manager, source, dest):
            return False

for r in allowed_rules:
        if label not in r.get_labels():
            continue

        if is_chain_exist(r, source_manager, source, dest):
            return True

# didn't find any good policy
return False
```
*листинг 6*

&nbsp;

###  Функция is_chain_exist

Как мы знаем из предыдущей главы, эта функция проверяет наличие какой-то конкретной цепочки между объектами `source` и `dest`. Для этого в качестве дополнительного аргумента в функцию передаётся объект менеджер, позволяющий реализовать внутри функции всё богатство возможностей Django ORM. В частности, для последовательного обращения к полям объектов нашего проекта мы можем использовать метод `filter` менеджера. Она пройдет по интересующей нас последовательности полей (и даже может применить любой поддерживающийся фильтр, о чем написано выше в главе) и вернёт только тех представителей изначального типа (к которому принадлежит `source`), для которых эта цепочка отношений с возможным фильтром применима. Нам остаётся лишь проверить, находится ли среди этих объектов наш исходный (сравнение происходит по ключу `id`, автоматически заполняемому Django)

Так как синтаксис требует сравнения конечного поля с каким-то значением, при отсутствии фильтра происходит сравнение поля `id` cо значением `id` объекта `dest` (таким образом мы оставляем только те объекты, которые имеют соответствующую цепочку отношение именно к интересующему нас объекту `dest`) 

Как это происходит на практике? Для последовательного обращения к нескольким полям именованный аргумент метода `filter` должен содержать имена полей в необходимом порядке, разделённые двойным подчёркиванием. Так, вызов функции из листинга 7

```Python
user_manager.filter("papers_of_user__paper_for_representative_department__id"=3)
```
*листинг 7*

Вернёт нам всех тех пользователей, для которых статья, к которой они имеют отношение `papers_of_user` (то есть статья их авторства) имеет отношение `paper_for_representative_department` (то есть её представляет отдел) с отделом, у которого `id` равняется трём. 

Значит надо на основе цепочки, переданной в функцию вместе с правилом, построить именованный аргумент нужного вида. 

```Python
complex_field_for_query = ""
    chain = rule.get_chain()

    value_of_last_field = dest.id

    for i, field in enumerate(chain):
        if i != len(chain) - 1:
            complex_field_for_query += field
            complex_field_for_query += "__"
        else:
            if isinstance(field, tuple):
                complex_field_for_query += field[0]
                value_of_last_field = field[1]
            else:
                complex_field_for_query += "id"
```
*листинг 8*

В примере с листинга 8 применяется описанный в правиле фильтр, либо используется как фильтр поле `id`  объекта `dest` . Наконец, из всех полученных объектов оставить только `source` (то есть только тот, у которого с ним совпадает `id`, что удобно задать новым фильтром). Если итоговый список пуст, значит искомое отношение между `source` и `dest` отсутствует, иначе присутствует. Именованный аргумент мы передаем через словарь, распаковывая его при вызове функции

```Python
 d = {complex_field_for_query: value_of_last_field}
result_object = source_manager.filter(**d).filter(id=source.id)
return result_object.exists()
```
*листинг 9*

&nbsp;

# Тестирование, логирование, архитектура проекта

### Общая структура

Данный проект, как было неоднократно описано выше, написан на Django. Токен подключается к проекту с помощью переменной окружения для повышения безопасности. Внутри Django проекта реализовано два приложения — `compiler` и `homepage`. Приложение `homepage` несёт тривиальный и служебный характер — обслуживание стартовой страницы, по которой осуществляется навигация между приложением администратора и приложением компилятора (внутри которого вызывается функция `compiler_function`).

```
homepage
├── __init__.py
├── __pycache__
├── admin.py
├── apps.py
├── models.py
├── templates
│   └── homepage
│       └── homepage.html
├── tests.py
├── urls.py
└── views.py
```
*структура приложения `homepage`*

Всё наукоёмкое содержание, относящееся непосредственно к компилятору политик, сосредоточено в приложении `compiler`. А именно папка `utils`, внутри которой находятся два достойных упоминания — `compiler_function.py` и `compiler_function_test.py`.

Во втором находятся фикстуры и тесты, написанные с помощью библиотеки pytest. В первом файле содержатся все функции и структуры, описанные в главе "Практическая реализация". Вызывается функция при переходе на подстраницу `/compiler` проекта, то есть вызов функции `compiler_function` реализована внутри файла `views.py` приложения

```
compiler
├── __init__.py
├── __pycache__
├── admin.py
├── apps.py
├── models.py
├── templates
│   └── compiler
├── tests.py
├── urls.py
├── utils
│   ├── __init__.py
│   ├── __pycache__
│   ├── compiler_function.py
│   ├── compiler_function_test.py
│   └── conftest.py
└── views.py
```
*структура приложения `compiler_function`*

&nbsp;

### Тестирование

Система тестирования проекта реализована с помощью библиотеки `pytest`. Внутри содержатся "happy path" тесты, крайние случаи в виде попытки доступа к несуществующим полям базы проекта. 

```Python
@pytest.fixture
def good_policy():
	r = Rule(
		Rule_category.ALLOWED,
		["edit", "create"],
		"person to department, which is representative for his paper",
		("papers_of_user", "paper_for_representative_department"),
	)
	p = Policy()
	p.add_rule(r)
	return p
```
*листинг 10. Фикстура корректной политики*

&nbsp;

### Логирование

Масштабируемость проекта должна быть обеспечена не только тестами. Также довольно важную роль в расширяемости проекта занимают логи. Среди великого разнообразия средств логирования мой выбор пал на `loguru`. Эта система обладает невероятно простым интерфейсом взаимодействия, что кажется важным для системы логирования — код остаётся читаемый и функциональным.

```Python
allowed_rules = policy.get_allowed_rules()
prohibited_rules = policy.get_prohibited_rules()

log.trace("Started prohibited policies") #logging
for r in prohibited_rules:
	if label not in r.get_labels():
		continue
```
*Листинг 11. фрагмент функции `compiler_function`, использующий логирование*

&nbsp;

# Заключение

Текущей работой было положено начало проекта, в будущем способного упростить жизнь разработчикам системы ИСТИНА. Пусть рассмотренный пример имеет  тренировочный характер, в нём есть огромный простор для улучшений и масштабирования. Среди потенциальных улучшений имеются

- Перевод функции `check_permission` в статус декоратора. 
- Поддержка псевдонимов для политик.
- Возвращать функциями `get_allowed_policies` и `get_prohibited_policies` сразу итератор, а не итерабельный объект, для упрощения итерирования по результату функции.
- Добавление функций для получения всех объектов, к которым у данного объекта есть доступ и наоборот — получения всех объектов, у которых к данному объекту есть доступ.
- Реализация вложенной структуры правил (правила, использующиеся внутри правил) и логических операций между ними.
- Добавление графического интерфейса.

и другие

После накопления критической массы полезного функционала вопрос добавления реально существующих моделей и политик будет требовать лишь временных затрат, поэтому потенциальная интеграция проекта в репозиторий ИСТИНЫ в обозримом будущем видится мне возможной.

&nbsp;

# Список литературы

1. Valery Vasenin, Alexander Itkes, Maxim Krivchikov. ChRelBAC data access control model for large-scale interactive informational-analytical systems
   Journal of Computer Virology and Hacking Techniques, 313-331pp., 2020
   https://link.springer.com/article/10.1007/s11416-020-00365-9
3. Sherif Sakr. Attribute-Based Access Control (ABAC)
   Encyclopedia of Big Data Technologies, 117p., 2019
   https://link.springer.com/referenceworkentry/10.1007/978-3-319-77525-8_100017
4. Ling Liu. RBAC.
   Encyclopedia of Database Systems, 2339p., 2009
   https://link.springer.com/referenceworkentry/10.1007/978-0-387-39940-9_3418